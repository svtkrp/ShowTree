<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Теория | Двоичная куча</title>
  </head>
  <body>
    <h1>Теория про двоичные кучи с корнем - минимальным узлом:</h1>
    <p><b>Двоичная куча</b> (англ. <i>Binary heap</i>) — такое двоичное дерево, для которого выполнены три <b>условия</b>:</p>
    <ol>
      <li>Значение в любой вершине не меньше (max binary heap) / <b>не больше (min binary heap)</b>, чем значения её потомков.</li>
      <li>Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.</li>
      <li>Последний слой заполняется слева направо без «дырок».</li>
    </ol>
    <h4>Вставка:</h4>
    <p>Добавим новый узел в конец кучи (в первое слева направо пустое место). Затем узел должен "всплыть". Если элемент больше своего отца, условие 1 соблюдено для всего дерева, и больше ничего делать не нужно. Если он меньше, мы меняем местами его с отцом. Если после этого отец больше деда, мы меняем местами отца с дедом и так далее. Иными словами, слишком маленький элемент всплывает наверх.</p>
    <h4>Удаление минимального узла:</h4>
    <p>Минимальный узел - корень. Вместо его старого значения записываем новое - значение последнего элемента кучи, после чего этот элемент удаляем. Затем значение корневого узла должно спуститься - для этого рекурсивно выполняем алгоритм спуска для узла с индексом i (первый раз - для корневого узла): алгоритм восстанавливает свойство упорядоченности во всём поддереве, корнем которого является элемент с индексом i. Если i-й элемент меньше, чем его сыновья, всё поддерево уже является кучей, и делать ничего не надо. В противном случае меняем местами значение i-го элемента со значением наименьшего из его сыновей, после чего выполняем спуск для этого сына.</p>
    <p><a href="MinBinHeap.html">Визуализация алгоритмов вставки нового узла и удаления минимального узла (корня) для двоичных куч...</a></p>
  </body>
</html>
